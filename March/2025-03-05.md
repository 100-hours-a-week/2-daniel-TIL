## 📌 INDEX

- 데이터베이스에서 검색 성능을 향상시키기 위해 사용되는 자료 구조로, 특정 컬럼에 대한 빠른 조회를 가능하게 함.
- 인덱스는 두 가지로 나뉘는데, 클러스터형과 비클러스터형이 있다.
- 클러스터 인덱스

테이블 자체가 기준에 맞춰 정렬된 것이다!

→ 데이터 조회시 테이블과 테이블 사이를 이동하여 찾아가는 것이 아니라 그냥 바로 접근하다.

→ 단 하나의 기준으로만 정렬할 수 있다.

- 비클러스터 인덱스 → 인덱스 테이블을 따로 만들고 거기서 찾고 원본 테이블에 찾아가 데이터를 가져옴

![](https://velog.velcdn.com/images/kdaehun00/post/d0590576-9102-4b55-8a0d-a9e5da023f67/image.png)

![](https://velog.velcdn.com/images/kdaehun00/post/bc9b4a50-be1e-45e3-9645-268e9f2b1cf0/image.png)

SELECT *
FROM A
WHERE b = 5 → a,b,c,d 컬럼을 전부 훑어야된다.

하지만 b에 대한 인덱스 테이블을 만들면 인덱스 테이블에서 b만 훑고 PK나 포인터를 저장한 후 원본테이블에 PK값을 대입해서 SELECT문의 값만 가져온다. (인덱스 테이블은 자동 정렬된 형태로 저장된다.)

장점: SELECT문이 정말 빠르다 (ex - 배민에서 음식점 조회할 때 사용하면 매우 빠름)

단점: INSERT같은 데이터 변화가 잦은 경우에는 원본테이블에 데이터가 삽입될 때마다 인덱스 테이블이 갱신되는데, 이 때 정렬을 다시 해줘야해서 효율이 떨어진다. (ex - 인스타 같은 피드 자주 올리는 환경에선 부적절)

- 하나의 테이블에 여러 인덱스를 생성한다면?
    - 옵티마이저가 최적의 경로를 결정해주겠지만, 그래도 설계단계에서 올바른 순서를 지정해야 한다.

---

## 📌 B-Tree / B+Tree

- **B-Tree**는 균형 트리 구조로 내부 노드에도 데이터를 저장하며, **B+Tree**는 모든 데이터를 리프 노드에 저장하여 범위 검색에 유리함. → 인덱스 활용할 때 사용하는 트리 구조.
- 다원 탐색 트리라고도 한다.
    - 자식 노드의 수가 m 개인 트리를 다원 탐색 트리라고 한다. 이진 탐색 트리는 m=2인 트리

📌 처음엔 이게 무슨 소리인지 이해가 잘 가지 않았다.. 하나의 노드 안에 데이터만 있냐, 인덱스+데이터냐 이 차이로 이해했다. ( [1, 50] 이냐 [50] 이냐 ) 근데 이런 개념이 전혀 아니었다.

아래의 두 사진은 [10, 20, 30, 40, 50, 60]인 배열을 각각 B-Tree, B+Tree로 짠 것이다.

- B-Tree
    
    ![Screenshot 2025-03-05 at 8.12.34 PM.png](attachment:ecb90412-377c-4989-8ae6-1c8a7f9b02cb:Screenshot_2025-03-05_at_8.12.34_PM.png)
    
- B+Tree
    
    ![Screenshot 2025-03-05 at 8.10.26 PM.png](attachment:39ab3eed-5ffa-404f-9b1a-72f8bcedc9da:Screenshot_2025-03-05_at_8.10.26_PM.png)
    

차이를 보면 B-Tree는 실제 데이터 중 하나를 내부 노드로 쓴다. 즉, 30이라는 값을 데이터로 사용함과 동시에 인덱스로도 사용하는 것이다.

반면 B+Tree는 데이터들 중 특정 값(오른쪽 노드들의 최솟값)을 뽑아 내부 노드로 사용하는데, 실제 데이터로 사용하는 것이 아니라 그냥 인덱스로만 사용한다. 즉, 내부 노드에서는 실제 데이터 값을 가져와 이정표로만 사용하고 실제 값은 리프노드에 있다.

따라서 B-Tree는 리프노드에 30이라는 실제 값이 비어있기 때문에 이것끼리 리스트로 연결할 수 없고, 리프노드에 모든 데이터가 들어있는 B+Tree는 데이터들끼리 연결할 수 있다. 그래서 범위 내의 값을 찾을 때에 유용하다.

B-Tree는 만약 상단의 배열에서 20이상 50 이하를 찾으려면 내부 노드인 30에서 왼쪽으로 가서 20 가져오고 다시 올라갔다가 오른쪽 가서 40, 50 가져오고 해야하는데, B+tree는 연결되어 있으므로 최솟값인 20으로 먼저 가서 가져오고 위로 다시 올라가는 것이 아닌 차례대로 오른쪽으로 가면서 50까지 가져오면 되는 것이다.

다만, 범위가 아니라 단일 노드를 찾을 때에는 B-Tree가 조금 더 유리하다. (내부 노드에도 데이터가 있기 때문에 때로는 리프노드까지 내려갈 필요가 없다.)

→ 비클러스터형 인덱스는 B-Tree 또는 B+Tree와 같은 구조로 구현. 인덱스의 각 페이지는 트리의 노드처럼 동작

---

## 📌 카디널리티

- 테이블의 특정 컬럼에서 고유한 값의 개수를 의미(중복은 하나로 계산)하며, 높을수록 중복이 적다.

## 📌 Selectivity

- 데이터 집합에서 특정 값을 얼마나 잘 골라낼 수 있는지를 나타냄
- Selectivity = Cardinality / Total Number of Records 이다. → 1에 가까울 수록 `인덱스로 적합`

---

## 📌 트랜잭션

- 데이터베이스에서 논리적으로 하나의 작업 단위로 실행되는 연산 묶음.

(은행에서 돈을 출금하고, 잔액을 조회하는 것은 두 개의 트랜잭션)

- 상태
    - Partially Committed (실행 완료, 영구적으로 기록만 안 함)
    - Aborted (트랜잭션 취소 후 이전으로 돌아감)
    - Failed (트랜잭션 실패 상태)
    - Committed (트랜잭션 완료)

- 📌 DBA환경에서의 트랜잭션
    
    **Monolithic 구조에서는 RDBMS의 트랜잭션(ACID)을 통해 데이터 일관성을 보장할 수 있다.**
    
    **하지만 MSA에서는 여러 개의 독립적인 서비스가 존재하고, 각 서비스가 개별 데이터베이스를 가질 수 있다.**
    
    - **예제: 쇼핑몰 주문 시스템 (MSA)**
    1. `OrderService` → 주문 생성
    2. `PaymentService` → 결제 처리
    3. `InventoryService` → 재고 차감
    
    **주문을 완료하려면 3개의 서비스가 성공적으로 실행되어야 하지만 ,중간에 `PaymentService`가 실패하면?**
    
    **데이터가 불일치(Inconsistency) 상태에 빠질 수 있다.**
    
    **→ 따라서, 여러 서비스에 걸쳐 있는 트랜잭션을 조율하는 메커니즘이 필요하다.**
    
    - ****📌 **2PC의 동작 방식**
    
    **2PC는 두 단계(Prepare → Commit)로 진행됨.**
    
    | 단계 | 설명 |
    | --- | --- |
    | **1. Prepare(준비 단계)** | Coordinator(조정자)가 모든 서비스에 "트랜잭션 실행 준비가 되었는가?"를 물어봄. |
    | **2. Commit(실행 단계)** | 모든 서비스가 OK를 응답하면, Coordinator가 실제 커밋을 수행. 만약 하나라도 실패하면 롤백(rollback). |
    
    모든 서비스가 "OK" 응답하면, Coordinator가 **Commit 수행**
    하나라도 실패하면, **Rollback 수행**
    
    → 모든 서비스가 응답해야하므로 성능이 안 좋다. 그리고 조정자에 에러가 나면 진행이 어렵다.
    
    → 2PC는 강한 일관성을 보장하지만, `성능과 장애 대응 측면`에서 `한계`가 있음.
    
    - 📌 **Saga 패턴의 동작 방식**
    
    **Saga는 두 가지 방식이 있음.**
    
    1. **Choreography(코레오그래피, 이벤트 기반 방식)**
    2. **Orchestration(오케스트레이션, 중앙 조정 방식)**
    
    **(1) Choreography 방식**
    
    - 각 서비스가 "이벤트"를 보고 알아서 트랜잭션을 실행
    - **각 서비스가 이벤트를 수신하면 자체적으로 트랜잭션을 실행하고, 성공하면 다음 서비스로 이벤트를 전달**
    - 실패하면 `보상 트랜잭션`을 실행하여 롤백.
    
    📌 **예제**
    1️⃣ `OrderService` → 주문 생성 이벤트 발행
    
    2️⃣ `PaymentService` → 주문 생성 이벤트 수신 후 결제 승인
    
    3️⃣ `InventoryService` → 결제 성공 이벤트 수신 후 재고 차감
    
    4️⃣ 하나라도 실패하면 보상 트랜잭션 수행 (ex. 결제 취소, 주문 취소)
    
    ✅ **(2) Orchestration 방식**
    
    - `Saga Coordinator(조정자)`가 모든 서비스의 트랜잭션을 관리함.
    - Coordinator가 각 서비스의 트랜잭션을 순차적으로 실행하고, 실패하면 보상 트랜잭션을 수행함.
    
    📌 **예제**
    1️⃣ `OrderService` → 주문 요청
    
    2️⃣ `Saga Coordinator` → `PaymentService` 호출 (결제)
    
    3️⃣ `Saga Coordinator` → `InventoryService` 호출 (재고 차감)
    
    4️⃣ 하나라도 실패하면 보상 트랜잭션 수행 (ex. 결제 취소, 주문 취소)
    
    ✅ **Saga는 Eventually Consistency를 보장하며, MSA에서 널리 사용된다!**
    

---

## 📌 ACID

- 트랜잭션의 신뢰성을 보장하는 4가지 속성으로 **Atomicity(원자성), Consistency(일관성), Isolation(독립성), Durability(영속성)**을 의미함.

ACID는 원자성, 일관성, 격리성, 영속성 입니다.

먼저 `원자성`은 트랜잭션이 완전히 실행되거나 아예 실행되지 않아야함을 의미합니다. 작업이 중간만 이루어지고, 데이터에 반영되면 안 된다는 것입니다.
`일관성`은 데이터가 제약조건과 여떤 규칙을 유지해야한다는 것입니다. 원자성이나 격리성에 어긋나거나 무결성에 어긋나도 일관성이 깨졌다고 말할 수 있습니다.
`독립성`은 트랜잭션이 독립적으로 실행되어있어야 한다는 것입니다. 어떤 값의 변경으로 연관없는 데이터의 값이 변경되어서는 안 됩니다. 예를 들어 금리가 바뀌었다고 그 사람의 통장잔액이 바뀌어서는 안 됩니다.
`영속성`은 커밋된 트랜잭션의 결과는 영구적으로 반영되어야 합니다. 이미 커밋되었는데 갑자기 다시 원래대로 돌아오면 안 됩니다.

---

## 📌 Isolation Level

- 트랜잭션이 서로 영향을 미치지 않도록 "얼마나 격리할 것인가"를 결정하는 설정.
- **Read Uncommitted < Read Committed < Repeatable Read < Serializable** 순으로 강도가 증가함.
→ **격리 수준이 높을수록 데이터 일관성이 보장되지만, 성능은 떨어짐.**

| **Dirty Read (더티 리드)** | **커밋되지 않은 데이터를 읽는 문제.**  - A 트랜잭션이 데이터를 변경했지만 아직 커밋하지 않았을 때, B 트랜잭션이 이를 읽는 경우. |
| --- | --- |
| **Non-Repeatable Read (반복 가능하지 않은 읽기)** | **같은 데이터를 두 번 조회할 때 값이 달라지는 문제.**  - A 트랜잭션이 데이터를 조회한 후, B 트랜잭션이 데이터를 수정하고 커밋하면, A가 다시 조회했을 때 값이 변경됨. |
| **Phantom Read (팬텀 리드)** | **조회하는 동안 새로운 데이터가 삽입되거나 삭제되는 문제.**  - A 트랜잭션이 특정 조건으로 데이터를 조회했는데, B 트랜잭션이 새로운 데이터를 삽입하고 커밋하면, A가 다시 조회했을 때 결과가 달라짐. |
- >

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |
| --- | --- | --- | --- | --- |
| **Read Uncommitted** | O (발생) | O (발생) | O (발생) | 매우 빠름 |
| **Read Committed (기본값)** | ❌ (방지됨) | O (발생) | O (발생) | 빠름 |
| **Repeatable Read** | ❌ (방지됨) | ❌ (방지됨) | O (발생) | 느림 |
| **Serializable** | ❌ (방지됨) | ❌ (방지됨) | ❌ (방지됨) | 매우 느림 |

---

## 📌 NoSQL

- 관계형 데이터베이스가 아닌 비정형 데이터를 저장·관리하는 DB로, 스키마 없이 유연한 확장이 가능함.

아까 RDBMS는 문법이 조금씩 다르긴 하지만 ,SQL 쿼리 구조도 거의 비슷하다고 하셨는데, 일반적으로 테이블의 형태로 저장된다.

하지만 NoSQL은 다양한 형태로 데이터가 저장될 수 있다.

- 키 - 값 저장소 ( ex - Redis )

```json
// ex) Key - Value 저장
{
    "user_1": { "name": "Alice", "age": 25, "email": "alice@example.com" },
    "user_2": { "name": "Bob", "age": 30, "email": "bob@example.com" }
}

//-> 복잡한 쿼리 불가능, ex- age > 25인 값만 뽑기

```

- ‘문서 지향 데이터베이스 ( ex - Mongo DB )
    - PDF, 이미지 파일 또는 텍스트 문서를 값으로 직접 저장할 수도 있다. → 문서는 xml이나 JSON 형태로 인코딩 되기 때문에
    - key - value 와 무슨 차이? → 간단한 키와 값이 아니라 문자열만 키로 사용될 수 있는 특수한 유형의 키-값 스토어이다.
    
    ![image.png](attachment:5f433dfd-4682-4c0a-bbca-2dee43b1be79:image.png)
    

- 컬럼 기반 데이터베이스 ( ex- Cassandra )
    - 컬럼 기반 저장소는 RDBMS처럼 테이블 형태로? 컬럼 기반으로 저장하지만 RDBMS와 다른 점이 컬럼마다 다른 값을 가질 수 있다.

RDBMS

![](https://velog.velcdn.com/images/kdaehun00/post/10311ac2-153e-49d0-b7c9-0829a03b11dd/image.png)

컬럼기반

![](https://velog.velcdn.com/images/kdaehun00/post/be255c19-e9d8-47a8-b435-19bdac083472/image.png)

→ null값을 굳이 채우지 않아서 메모리 효율이 좋다.

- 그래프 데이터베이스 ( ex- Neo4j )
    - 데이터를 노드와 엣지로 표현, 객체 간의 관계를 중심으로 데이터를 저장하고 조회

---

## 📌 Eventual Consistency

- 분산 시스템에서 일시적으로 데이터 불일치가 발생할 수 있지만, 일정 시간이 지나면 일관성이 유지됨을 보장하는 개념. → 아까 유트브 조회수? 말씀하신 부분

AP 시스템 (가용성 + 네트워크 분할 허용)에서 많이 사용됨.

---

## 📌 CAP 이론

- 분산 시스템(서버 여러 대로 운영되는 시스템)을 구성하려면 다음의 3가지 중에서 하나는 포기해야하는 상황이 옴. **Consistency(일관성), Availability(가용성), Partition Tolerance(네트워크 분할 허용성)** 중 두 가지만 동시에 만족할 수 있다는 이론. 즉, 3가지 특성을 모두 만족할 수 없다.

| **C (일관성, Consistency)** | **모든 노드에서 같은 데이터를 가져야 한다.**  예: 내가 `A=10`을 저장하면, 모든 서버에서 `A=10`이어야 한다. |
| --- | --- |
| **A (가용성, Availability)** | **모든 요청에 대해 응답해야 한다.**  예: 서버가 일부 다운되어도, 나머지 서버가 계속 응답해야 한다. |
| **P (네트워크 분할 허용, Partition Tolerance)** | **네트워크 문제가 발생해도 시스템이 정상적으로 동작해야 한다.**  예: 서버가 여러 대일 때, 일부 서버가 서로 통신하지 못해도 서비스가 계속되어야 한다. |

**→ 분산 시스템에서는 네트워크 장애(P)를 피할 수 없으므로, CA(일관성+가용성)은 현실적으로 불가능함.**

**결국, `CP(일관성+분할 허용)` 또는 `AP(가용성+분할 허용)` 중 하나를 선택해야 함!**

1. 모든 서버가 동일한 데이터를 갖도록 동기화 하는동안 클라이언트의 접근을 막는 경우 (가용성의 문제)
2. 다른 클라이언트들이 변경된 데이터를 요청했을 때 어떤 클라이언트는 최신의 데이터를, 어떤 클라이언트는 오래된 데이터를 받게되는 경우.(일관성의 문제)

| **CA (일관성 + 가용성)
→ 네트워크 포기?** | 모든 노드가 항상 동일한 데이터를 반환 & 모든 요청에 응답 가능. 하지만 네트워크 분할이 발생하면 동작 불가. | 단일 노드 RDBMS (ex: MySQL 단일 서버) |
| --- | --- | --- |
| **CP (일관성 + 분할 허용)
→ 가용성 포기**
 | 네트워크 분할이 발생하면 일부 요청을 차단하더라도, 모든 노드가 같은 데이터를 유지하도록 보장. | **HBase, MongoDB(일부 설정), Zookeeper
→ 은행에서 점검하려고 새벽에 계좌이체 안 되는 거** |
| **AP (가용성 + 분할 허용)
→ 일관성 포기** | 네트워크 분할이 발생해도 응답을 보장하지만, 노드 간 데이터가 일시적으로 불일치할 수 있음. | **Cassandra, DynamoDB, CouchDB** |

---

## 📌 객체지향 4대 요소 (면접 답변)

**캡슐화**: 데이터와 메서드를 하나로 묶고 외부에서 직접 접근을 제한함.

**상속**: 기존 클래스의 속성과 메서드를 새로운 클래스에서 재사용하는 개념.

**다형성**: 동일한 인터페이스를 통해 서로 다른 구현을 수행할 수 있는 특성.

**추상화**: 핵심적인 속성과 동작만을 정의하여 복잡성을 줄이는 개념.

---

## 📌 추가 (현업에서 자주 봤던 쿼리)

Case - when

윈도우 함수 over() ~~

Order by, Group by

---

## 📌 더 생각해보기

- B+Tree는 색인순차검색(ISAM)인가?
    - 색인순차검색은 색인이 가르키는 포인터를 따라가서 데이터를 가져오는 방식으로 B+Tree와 비슷하다. 하지만 데이터 변경을 대처하는 부분에서 다르다.
    - 색인 순차 검색은 데이터가 들어오거나 변경되면 반영하지 않고 오버플로우 블록에 저장되어 `정적`이다.
    - B+Tree는 데이터가 들어오거나 변경되면 바로 반영되어 `동적`이다.

- Like ‘% %’ 사용 남발
    - Like를 너무 많이 사용하면 좋지 않다. 인덱스를 타지 않기 때문이다.
    → 앞에서부터 일정한 패턴이 있어야 그걸 따라가는데, 앞에 % 써버리면 인덱스에 의미가 사라지기 때문
    - 경험: 현업에서도 특정 조건에 해당되는 고객들의 정보를 저장하고 쿼리를 날릴 때 Like 문을 썼는데 진짜 효율이 너무 안 좋았다. count하고 다른 테이블에 Insert 시키는 작업이 30분은 걸리는 것도 있었다.. 그 땐 그냥 몇 십만명을 조회하기 때문이구나라고 생각하고 넘겼는데, 이제 생각해보니까 Like를 진짜 엄청 남발한 쿼리로 작성하였다. idx_라는 인덱스가 존재하긴 했던 것 같은데 어떻게 사용했는지는 잘 모르겠다.
    - `search_fields` (Django Admin)( `Admin` 패널 방식) 사용
        - Django에서 검색을 할 때 위의 함수를 사용하면 저절로 LIKE문이 실행된다. 그래서 효율이 너무 안 좋다고 하는데 뭐`LIKE '검색어%'` 패턴을 사용하거나, PostgreSQL을 이 문제를 해결? 성능을 개선? 할 수 있다.
        - PostgreSQL을 사용한다면 `pg_trgm`을 적용하여 `LIKE '%검색어%'`도 인덱스를 활용할 수 있도록 최적화 가능하다고 한다. 그래서 PostgreSQL을 많이 쓰는 건가 싶었다.

## 📌 Redis

- 데이터베이스로서의 Redis
    - Redis는 사전 같은 구조를 통해 데이터를 저장하고 관리할 수 있도록 한 것이다. 여기서 `사전같다` 라고 함은 key - value로 이루어진 데이터를 말한다.
    - 레디스는 **데이터를 저장하는 공간**이 특별하다. 일반적으로 mysql, oracle 등의 RDB들이 하드디스크에 데이터를 저장하고 관리하는 것과는 달리 레디스는 데이터를 `주기억장치`인 **`ram`, 즉 `In-memory`**에서 관리한다. 인메모리 방식이라 빠르지만, 따라서 서버에 장애가 발생하면 DB가 유실될 수 있다. 또, ram은 휘발성이라 불안하기도 하고, 너무 많은 양을 저장하면 서버에 문제를 야기할 수도 있다.
    
- 캐싱서버로서의 Redis
    - 토큰 등을 통해 계정 인증 정보 등을 저장하는 용도, 데이터의 사용 기한을 설정할 수 있는 **expire** 기능을 사용하면 좋다!
    - 자주 접근하는 DB 데이터를 잠시 저장하는 용도
    
    → 즉, 유실되어도 괜찮은 것들을 저장해놓는 용도로 사용한다.
    

## 📌 Mongo DB

RDBMS가 아니기 때문에 ACID 한 트랜잭션이 아닌 BASE를 기반으로 하여 엄격하진 않다. 라고 생각했는데, MongoDB 4.0 이상부터는 지원한다고 한다.

BSON 형태로 JSON보다 빠르게 처리할 수 있다.

그리고 스키마가 없기 때문에 정형화해서 값을 집어넣어야 한다는 개념이 없다. (컬럼도 맞추고 null도 생각하는 등등) → 그냥 문서에 저장한다는 생각으로 저장했다가 나중에 필요할 때 빼면 된다.

## 📌 키-값 저장소 / 문서 지향 데이터베이스 차이?

키-값 저장소는 우선 인메모리를 사용하므로 간단한 캐싱같은 거에 적합하다. 그리고 구조도 뭔가 간단한 거 같다.

문서 지향 데이터베이스는 schemaless 하여 자유롭게 데이터 저장이 가능하고 필드 검색도 가능하다. 그리고 기본적으로 테이블이 아닌 도큐먼트 단위(?)이다.

- Schemaless의 등장 배경?
    - 복잡한 데이터, 데이터의 다양성, 방대한 양의 데이터들을 정형화 시켜서 관리하기 어렵다.
    - RDBMS는 스키마를 한 번 만들면 변경하기 어렵지만, NoSQL은 관계없이 데이터 저장 가능
    - NoSQL은 저장도 쉽고, 수평적 확장도 가능하기 때문에 여러 서버에 데이터를 분산시켜 높은 트래픽과 대규모 데이터를 효율적으로 관리할 수 있다.
    - 하지만 복잡한 쿼리를 사용할 수 없고 데이터의 정합성 보장이 어렵다는 단점이 있다.

## 📌  낙관적 동시성 제어 (OCC)

- 데이터베이스 시스템에서 동시에 여러 트랜잭션이 데이터를 조작할 때 충돌을 관리하는 방식 중 하나
- 트랜잭션을 시작할 때 충돌 가능성을 점검하지 않고, 트랜잭션이 커밋되는 시점에서만 데이터 충돌을 검사
→ 충돌이 감지되면 트랜잭션을 롤백한다.
- 낙관적 동시성 제어는 다음과 같은 단계를 거쳐 동시 업데이트를 제어.

| 단계 | 설명 |
| --- | --- |
| **1. Read (읽기)** | 데이터를 읽어옴 (예: `SELECT * FROM products WHERE id=1;`) |
| **2. Modify (수정)** | 데이터를 수정하려고 함 |
| **3. Validate (검증)** | 업데이트 전에 다른 사용자가 데이터를 변경했는지 확인 |
| **4. Write (쓰기)** | 데이터가 변경되지 않았다면 업데이트 수행, 변경되었다면 충돌 해결 |

📌  **낙관적 동시성 제어(OCC) 적용 예제**

```sql
sql
CopyEdit
-- Step 1: 데이터 읽기
SELECT stock, version FROM products WHERE id = 1;

-- Step 2: 변경하려는 데이터 준비
UPDATE products
SET stock = stock - 5, version = version + 1
WHERE id = 1 AND version = 1;
```

**여기서 `version` 필드를 사용하여 충돌 감지 가능!**

**동일한 `version`을 가진 데이터만 업데이트 가능하므로, 다른 사용자가 먼저 변경하면 업데이트 실패.**

📌 위의 예시 말고도 기차표나 영화표 예매할 때, 들어가서 자리가 있어서 예매하기 클릭하면 이미 좌석이 있다고 뜨는 것과 같은 느낌이라고 생각했다.

이렇듯 동기화가 바로바로 이루어지지 않으므로 이러한 상황이 오면 어떻게 처리할지 개발자가 직접 관리해야한다!

- 직접 무결성 제어하는 방법?
    - version 사용
    - 비교 교환 (CAS) → 트랜잭션 없이 동시 업데이트 금지 (NoSQL에서 자주 사용 특히 Redis?)
    - 분산 트랜잭션 적용 (saga)