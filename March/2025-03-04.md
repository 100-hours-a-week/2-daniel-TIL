 # DB 정리

### 📌 신경썼던 점: 
실제 면접처럼 대답하기(격식체 사용!)

---
### 📌 더 노력했던 부분: 
1. 두괄식으로 먼저 설명하기 위해 노력하였다.
2. 대답과 연관된 꼬리질문들을 생각하며 더 깊이있게 공부하고자 하였다.

---
### 📌 나만의 언어로 정리: 

- DB에서 일관성과 무결성
    - DB에서 일관성은 작업이 끝난 전과 후가 동일해야한다는 것입니다. 이는 트랜잭션에 의해 보장이 가능한데, 만약 A라는 작업에서 생년월일을 수정할 때 년월만 수정하고 오류가 발생해 일을 수정하지 못한 채 저장한다면 이는 일관성에 어긋한 사례라고 볼 수 있습니다.

        - 고쳐야 할 점: 작업이 끝난 전후가 같다는 말은 트랜잭션의 원자성에 대한 것이라 모호하다. 이 부분은 데이터베이스의 제약 조건과 규칙을 유지하는 것이라고 바꾸자. 즉 무결성이 깨지면 일관성도 깨진 것이다.

    - DB에서 무결성은 데이터에 대한 제약을 맞춰야함을 의미합니다. 3가지의 무결성이 있는데, 먼저 개체 무결성은 null이 아닌 기본키가 있어야 한다는 것입니다. 두 번째는 참조 무결성입니다. 외래키가 존재하는데, 이는 다른 기본키의 값과 동일한 상태이거나 참조하는 값이 없으면 null로 존재할 수 있습니다. 하지만 잘못된 값을 참조하고 있다면 어긋된 사례라고 볼 수 있습니다. 마지막으로 도메인 무결성은 데이터의 범위나 제역조건, 형식을 맞춰야 한다는 것입니다. 나이에 숫자가 아닌, 문자열이 들어온다면 무결성을 해친 사례라고 볼 수 있습니다.

        - 추가하면 좋은 점: 참조 무결성 부분에서 외래키가 기본키를 참조하다가 기본키가 삭제되면 어떻게 되는지에 대해 조금 더 설명하면 좋다. 이럴 때 ON DELETE CASCADE 나 ON DELETE SET NULL을 사용할 수 있다.

---
- key의 종류
    - DB에서 Key는 기본키, 대체키, 후보키, 복합키, 슈퍼키, 외래키, 유니크키가 있습니다. 특정 튜플을 식별할 수 있는 키는 모두 후보키이고, 이 후보키는 최소성을 만족해야합니다. 이 후보키 중, 하나를 기본키로 지정하면 기본키가 되지 못한 나머지 후보키는 대체키로 됩니다. 예를 들어 id값과 주민번호가 후보키일 때, id값이 기본키가 된다면 주민번호는 대체키가 됩니다. 그리고 복합키는 두 가지 이상의 컬럼이 합쳐저 특장 튜플을 식별할 수 있는 키입니다. 예를 들어 같은 학교에 동명이인이 있다고 하면, 몇학년 몇반 몇 번 누구와 같이 여러 컬럼을 합치면 특정할 수 있습니다. 슈퍼키 또한 특정 튜플을 식별하는 키입니다. 하지만 최소성을 만족해야하는 후보키와는 다르게 슈퍼키는 그러지 않아도 됩니다. id와 이름을 합친다면 후보키는 아니지만, 슈퍼키라고 할 수 있는 것입니다. 외래키는 다른 기본키값을 참조하는 키값이고 null을 허용합니다. 이 때 참조하던 기본키 값이 삭제되면 그에 맞게 설정할 수도 있습니다. 유니크키는 앞선 키들과는 다르게 데이터 삽입시 중복을 방지해주는 키로 이미 있는 이메일값을 넣으려고 한다면 중복으로 처리합니다. 단 null도 허용하기 때문에 Not null을 설정해주는 것이 좋습니다.

        - 더 알면 좋은 내용

            자연키는 받아온 있는 그대로의 정보중 사용하는 키값이다. 예를 들어 주민번호는 정보중의 일부이므로 이를 키값으로 사용하면 자연키이다.
            인조키는 인위적으로 만든 키이다. 사용자마다 Id값을 부여하여 이를 키값으로 사용한다면 그것은 인조키이다.

            유일성은 중복되는 값이 없는 것이고
            최소성은 최소 필드만 사용하여 만든 것이다.
            
            -📌 복합키를 사용해야하는 경우?
            하나의 컬럼, 속성값으로 구분할 수 있으면 좋은 거 아닌가? 라는 생각이 들었다. 그래서 복합키는 그냥 가독성을 위해 사용하는 건가?라는 생각도 들어 찾아보았다. (전체 게시물을 관리할 때 게시물은 id로 관리하지 않고, 어떤 user_id의 몇 번째 게사물 post_id를 묶어서 사용하면 가독성이 좋다고 생각했기 때문에)
            뭐 이런 것도 있지만 실무에서는 `다중 로그인 기능`을 위해 사용한다고 한다. user_id와 device_id를 묶어 관리하면 같은 유저에 여러 가지 기기 정보들을 묶고 리프레쉬 토큰도 따로 관리할 수 있기 때문이다.
            
            
---
- 정규화/역정규화의 필요성

- 정규화
먼저 데이터의 무결성을 보장하기 위해 잘개 쪼개어 관리하는 것이 효율적입니다. 예를 들어 한 테이블에 모든 정보를 모아놓으면, 튜플의 수도 많아지고 복잡해지며 정보를 수정할 때 이곳저곳에서 수정해야합니다. 따라서 총 5정규형까지를 진행합니다. 1정규형은 단순히 하나의 컬럼에는 하나의 값만 존재하도록 나누는 것입니다. 2정규형은 완전 함수 종속을 만족하기 위해 테이블을 분리합니다. 기본키의 부분 집합이 어떤 컬럼의 결정자가 되면 안 됩니다. 3정규형은 이행적 종속성을 없애는 것입니다. A가 B를 바라보고 B는 C를 바라볼 때 다시 A는 C를 바라보는 루트를 끊어주는 것입니다. BDNF 정규형은 모든 결정자가 후보키가 되도록 하는 것입니다. 4정규형은 다치 종속을 제거하는 것입니다. 하나의 칼럼에서 다치 종속적인 것을 없애는 것입니다. 5정규형은 조인 종속을 제거하는 것인데, 조인 종속이란 나눈 테이블을 다시 join했을 때 원래 테이블이 되는 경우입니다.

이러한 정규화를 거치면 좋기만 할까요? 아닙니다. 5정규형 같은 경우 꼭 필요할 때 나누는 것은 좋지만 굳이 나눌 필요가 없을 땐 나누지 않는 것이 좋습니다.


2차 정규화사진 첨부
![](https://velog.velcdn.com/images/kdaehun00/post/c6bd249a-5310-46aa-b08f-bad1d86cc7aa/image.png)

- 역정규화
데이터를 너무 쪼개서 join하면 성능이 저하될 수 있습니다. (이유는 join 부분에서) 따라서 굳이 쪼개지 않아도 되는 부분은 데이터를 합쳐 사용하는 것이 좋습니다.

---
- join

join을 할 때 중첩조인이라는 것이 있는데, 드라이빙 테이블이 이너 테이블의 모든 행을 훑고 지나가기 때문에 이를 조절해주어야 성능이 개선된다. 드라이빙 테이블도 잘 선정하는 것이 좋지만 이것은 옵티마이저가 해주기 때문에..우리는 인덱스를 신경쓰면 좋다.

드라이빙 테이블 선정 기준 (옵티마이저가 결정하는 방식)
1. 결과 행이 적은 테이블을 먼저 읽음 (SELECTIVITY, 선택도 고려)
→ 작은 테이블을 먼저 읽으면 전체 연산량을 줄일 수 있음
2. 인덱스가 있는 테이블을 이너 테이블로 사용
→ 이너 테이블에 적절한 인덱스가 있으면, 검색 성능이 크게 향상됨
3. 테이블 크기 & 통계를 기반으로 실행 계획(Execution Plan) 수립

종류로는 
inner join 과 outer join이 있는데, inner 조인은 드라이빙 테이블이 무엇이든 결과는 같으니 상관없지만, outer join은 결과가 달라지므로 잘 선정해야한다. 또 join을 사용할 때에는 주의할 점이 있는데, 드라이빙 테이블에 중복되는 값이 있다면 데이터가 꼬인다. 또, 드라이빙 테이블에는 값이 있는데 이너 테이블에는 없으면 그 값은 null이 될 수도 있다. 기본키 값은 중복이 없는데 중복되는 값이 있을 수가 있나?라고 생각할 수 있지만, 실제 DB업무할 때 pk관련 오류를 피하기 위해 pk처럼 사용하지만 pk로 지정해놓지 않고 사용하는 경우도 있었기 때문에.. 잘 생각하고 사용해야한다. 이렇게 중복도 신경써야하고 데이터가 꼬이는 것도 신경써야하는데, 이를 윈도우 함수로 최대한 대체하여 사용하면 좋다!

- 윈도우 함수
집계함수로 자주 사용하는데 누적합 계산이나 순위 매길 때 많이 썼다. 마일리지를 계산하는 쿼리도 자주 접하다보니 OVER를 정말 많이 쓰는 것을 보았다. 어렵지만 이렇게 윈도우 함수를 적재적소에 잘 사용하면 더욱 DB 관리를 잘 할 수 있지 않을까 ..
![](https://velog.velcdn.com/images/kdaehun00/post/261bf4af-8b2f-4a96-a9d1-fece7e76da7c/image.png)

---
- UNION
2개 이상의 별도의 조회 쿼리 결과 값을 한번에 보고 싶을 때 UNION을 쓰게 됩니다. 일반적인 UNION은 중복을 제거해주기 때문에 인덱스를 생성해야하고 그 과정에서 성능저하가 발생합니다. 반면 UNION ALL은 중복을 허용하기 때문에 위의 UNION보다는 성능이 좋습니다. 따라서 단순히 쿼리 결과를 합치기 위해서 사용한다면 UNION ALL이 낫고, 중복된 값을 제거하고 싶다면 Distinct을 사용하는 것이 좋습니다.

---
- Group by / Having
Group by는 같은 값을 가지고 있는 것들끼리 그룹화하여 묶는 것을 의미합니다. 따라서 Select 문에는 sum이나 Count 같은 합계 함수가 포함되어야 합니다. Where절은 그룹화 되기 전의 데이터들에 조건을 걸어주는 것이라면 Having은 Group by 된 결과에서도 조건을 걸어 결과값을 출력해주는 역할을 합니다. 예를 들어 합이 1,000원이상인 값을 출력할 때에는 Having을 통해 조건을 걸어주는 것입니다.
- 경험: 쿼리문을 작성할 때 `Group by없이 Select 문에 집계함수를 작성한 적`이 있다. 이 때 Select에 집계함수만 넣은 것이 아니라 일반 데이터도 넣었는데, 오류가 발생했다. `Select에 집계함수를 넣는 순간, 전체를 하나의 그룹으로 인식하기 때문에 Group by가 없이는 일반 데이터를 사용할 수 없는 것`이다. 따라서 Group by가 없이 Select문에 집계함수를 사용할 수 있지만 `집계함수`만 들어갈 수 있다는 점을 배웠다.

---
- View
View는 데이터베이스에서 테이블의 일부 또는 ‘특정 조건에 따라 필터링된 데이터만’을 포함하는 ‘가상 테이블’입니다. 말 그대로 가상테이블이기 때문에 물리적인 데이터를 저장하지 않고 논리적으로만 보여주기 때문에 데이터의 중복없이 사용할 수 있습니다. 자주 조인하여 사용하는 테이블이 있으면 View를 만들어놓고 이를 사용하면 가독성과 보안성에도 좋고, 매번 조인해야하는 일 없이 View를 사용하면 되기 때문에 편리했습니다. 하지만 테이블 구조가 바뀌면 View를 새로 만들어줘야하고, View를 사용할 때마다 계속 테이블을 조회해야하므로 성능이 저하될 우려가 있습니다. 따라서 Materialized View가 나왔습니다.

Materialized View는 쿼리 결과를 미리 저장하여 빠르게 조회할 수 있도록 최적화된 뷰입니다. 데이터를 저장해놓기 때문에 테이블을 계속 조회하지 않아도 됩니다. 하지만 미리 저장해놓기 때문에 데이터가 변경되면 갱신이 필요합니다. 따라서 데이터가 바뀌지 않는 환경에서 유리합니다.

View는 단순한 사용자 조회와 같은 것에 적합하고
Materialized View Group by를 사용하는 월별 합계와 같은 작업을 수행할 때 가장 적합합니다.

---
- Char / Varchar

경험 - 예전에 ERP 주소록 (F0101??) 테이블에서 회사명을 char로 선언해놓였던 적이 있었다. 이 때 정확한 회사명으로 검색해도 결과가 나오지 않아서 당황한 적이 있었다. char로 하면 빈 공간을 공백으로 집어넣기 때문에 LIKE '% %' 붙여줘야 조회가 되는 문제점이 있었다. 이미 있던 테이블이기에 그냥 사용했는데, char와 varchar를 잘 구분해서 사용해야겠다는 생각을 하였다. (관련은 없지만 이 사용자 이름에 대한 varchar 값을 넣는 게 어려웠다.. 보통 외국인이 있다고 가정해도 varchar값을 작게 줄 수 있는데, 가끔 단체, 연합에서 가입을 해버리면 넘어가버려서 오류 생기는 경우도 있었다.. 일단 크게 배치하는 게 맞을까?)

Char - 고정형 데이터 타입으로 선언한 바이트보다 적게 입력하면 나머지는 공백으로 매꿔집니다. 하지만 별다른 계산없이 빠르게 접근할 수 있으므로 전화번호나 사업자번호, 우편번호처럼 고정된 값에서 사용하면 좋습니다.

VarChar - 가변형 데이터 타입으로 선언한 바이트에 따라 할당됩니다. 메모리 사용을 최소화할 수 있다는 장점이 있지만, 길이 정보가 함께 저장되기 때문에 읽기 전에 별도의 계산이 필요하므로 잘 사용해야합니다. 사는 주소나 이름 등 다양한 길이의 데이터를 받을 때 적합합니다.

---
- DateTime / TimeStamp
	
    - TIMESTAMP 
	1. 사용자의 별도 입력이 없으면 데이터가 마지막으로 입력되거나 변경된 시간이 저장되며 기본적으로 NOT NULL이다. 
	2. 시스템의 TIME_ZONE에 의존한다.
	3. TIMESTAMP는 숫자형으로 저장된다.(1970년 1월 1일 자정을 기준으로 몇 초가 지났는지를 저장한다.) -> 4바이트 저장공간 사용
	4. 로그 데이터(예: 사용자의 마지막 로그인 시간)나 변경 추적 시스템에서 유용하며, 자동으로 갱신되는 기능을 활용할 수 있다.
    
    
    
    - DATETIME

    1. 데이터 값을 입력해주어야만 날짜가 입력이 된다. (default 값을 설정해준 경우 제외)
    2. 시스템의 TIME_ZONE이 변경되어도 값이 변하지 않는다.
    3. DATETIME은 바이너리 형식으로 저장되고 있는 그대로 저장된다. -> 8바이트의 저장 공간을 사용한다.
    4. 타임존 영향을 받지 않기 때문에, 글로벌 서비스에서 예약 시스템이나 이벤트 스케줄 관리 등에 사용하기 적합하다.

아래는 해커톤 때 TIME_ZONE을 설정해준 것이다. 위의 내용을 공부하면서 아 이래서 사용했구나라고 느꼈다.
![](https://velog.velcdn.com/images/kdaehun00/post/60f9d1de-2b7f-4f52-a47b-3faf61be8e65/image.png)

하다가 예전에 Julian date라는 거 배웠는데, 한자리 한자리가 너무 귀해서 6자리의 날짜타입을 사용했다고 한 게 기억났다. JDE에서는 아직 사용했던 거 같은데 저런 형식의 date type만 보다가 깔끔하게 보이니까 너무 편했다


---
- ERD
ERD는 데이터베이스를 설계할 때 엔티티(개체)와 그 관계를 시각적으로 표현하여 구조를 쉽게 이해하고 관리할 수 있도록 합니다. 표기법에는 Peter-Chen 표기법, 까마귀 발 표기법, IE 표기법과 Baker 표기법이 있습니다.
ERD에서는 개체 간의 관계를 정의할 때, 관계의 종류를 명확히 하는 것이 중요합니다. (1:1, 1:N, N:1, N:M)
관계에는 식별/비식별 관계와 전체 참여/부분 참여 관계가 있습니다.
엔티티는 유무형에 따른 엔티티, 발생 시점에 따른 엔티티가 존재하며
속성은 엔티티 구성 방식에 따른 분류 (PK/FK/일반)과 속성의 특성에 따른 분류(기본/설계/파생)이 있습니다.
관계유형에는 필수/선택 관계와 연관/의존 관계가 있습니다.